function get_geotable_adjective(key) {
  var adjective_string = 'streets|light|dark|satellite|streets-satellite|wheatpaste|streets-basic|comic|outdoors|run-bike-hike|pencil|pirates|emerald|high-contrast'.replace(/-/g, '[-_]');
  try {
    return RegExp('(' + adjective_string + ')_geotable').exec(key)[1].replace(/_/g, '-');
  } catch(e) {
    return 'streets';
  }
}

function draw_map(k, v) {
  var map_id = k + '-map', table_id = k + '-table';
  var map = L.mapbox.map(map_id, 'mapbox.' + get_geotable_adjective(k)), features = [], feature_packs = v[0], properties = v[1];
  for (var i = 0; i < feature_packs.length; i++) {
    var p = feature_packs[i], geometry_type_id = p[0], geometry_coordinates = p[1], d = $.extend({'color': 'black', 'weight': 2, 'opacity': 0.7, 'fillColor': 'yellow', 'fillOpacity': 0.5}, properties, p[2]), feature;

    switch(geometry_type_id) {
      case 1:
        if (d.radius_in_meters) {
          feature = L.circle(geometry_coordinates, d.radius_in_meters, d);
        } else {
          feature = L.circleMarker(geometry_coordinates, d);
          d.radius_in_pixels && feature.setRadius(d.radius_in_pixels);
        }
        break;
      case 2:
        feature = L.polyline(geometry_coordinates, d);
        break;
      case 3:
        feature = L.polygon(geometry_coordinates, d);
        break;
      case 4:
        // MultiPoint
        break;
      case 5:
        feature = L.multiPolyline(geometry_coordinates, d);
        break;
      case 6:
        feature = L.multiPolygon(geometry_coordinates, d);
        break;
    }

    feature.geotable = {'table_id': table_id, 'tbody_id': table_id.replace('-table', '-row') + i};
    feature.on('click', function() {
      var a = this.geotable;
      var b = $('#' + a.tbody_id).show();
      $('#' + a.table_id + ' tbody').not(b).hide();
      $('#' + a.table_id).show();
    });
    features.push(feature);
  }
  if (features.length) {
    map.fitBounds(L.featureGroup(features).addTo(map).getBounds()).on('click', function() {
      $('#' + table_id).hide();
    });
  }
}

$('.geotable-upload').on('uploaded.ir.upload', function(e, d) {
  var upload_id = d.id;
  var field_id = $(this).parent().data('name');
  var target_id = field_id + '-upload';
  var $target = $('#' + target_id);

  $.post('/c/geotable/import_geotable', {'id': upload_id, 'name': field_id})
    .fail(function(d) {
      $target.find('.geotable-map').html(d.responseJSON[field_id]);
    })
    .success(function(html) {
      $('[name=' + target_id + ']').val(upload_id);
      $target.html(html);
      var x = $target.find('script').text();
      var y = '[[' + /(\[.*\]);/.exec(x)[1];
      var z = $.parseJSON(y.replace(/'/g, '"'));
      draw_map(field_id, z);
    });
});

L.mapbox.accessToken = d.crosscompute.geotable.mapbox_token;
$.each(d.crosscompute.geotable.definitions, draw_map);

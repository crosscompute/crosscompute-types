{% from 'invisibleroads_uploads:templates/parts.jinja2' import render_upload_button %}

{% macro head_style_loaded() %}
<link rel="stylesheet" href="//api.mapbox.com/mapbox.js/v2.3.0/mapbox.css">
{# <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/v0.18.0/mapbox-gl.css'> #}
{% endmacro %}

{% macro head_style_inline() %}
.geotable-map {height: 300px}
.geotable-table {display: none}
{% endmacro %}

{% macro head_script_inline() %}
d.crosscompute.geotable = {};
d.crosscompute.geotable.definitions = {};
{% endmacro %}

{% macro body_script_loaded() %}
<script src='//api.mapbox.com/mapbox.js/v2.3.0/mapbox.js'></script>
{# <script src='https://api.mapbox.com/mapbox-gl-js/v0.18.0/mapbox-gl.js'></script> #}
{% endmacro %}

{% macro body_script_inline() %}
function get_geotable_adjective(key) {
  {# var adjective_string = 'basic|bright|streets|light|dark'; #}
  {# https://www.mapbox.com/mapbox-gl-js/example/satellite-map/ #}
  var adjective_string = 'streets|light|dark|satellite|streets-satellite|wheatpaste|streets-basic|comic|outdoors|run-bike-hike|pencil|pirates|emerald|high-contrast'.replace(/-/g, '[-_]');
  try {
    return RegExp('(' + adjective_string + ')_geotable').exec(key)[1].replace(/_/g, '-');
  } catch(e) {
    return 'streets';
  }
}
L.mapbox.accessToken = '{{ get_os_environment_variable('MAPBOX_TOKEN', 'pk.eyJ1IjoiaW52aXNpYmxlcm9hZHMiLCJhIjoiY2lteHZianlxMDNuN3V3bTRnYjdsZTdycSJ9.xLgWezLxrs7TR11XqONWeQ') }}';

function draw_map(k, v) {
  var map_id = k + '-map', table_id = k + '-table';
  var map = L.mapbox.map(map_id, 'mapbox.' + get_geotable_adjective(k)), features = [], feature_packs = v[0], properties = v[1];
  {# var map = mapboxgl.Map({container: map_id, style: 'mapbox://styles/mapbox/' + get_geotable_adjective(k) + '-v8'}), features = [], feature_packs = v[0], properties = v[1]; #}
  for (var i = 0; i < feature_packs.length; i++) {
    var p = feature_packs[i], geometry_type_id = p[0], geometry_coordinates = p[1], d = $.extend({'color': 'black', 'weight': 2, 'opacity': 0.7, 'fillColor': 'yellow', 'fillOpacity': 0.5}, properties, p[2]), feature;

    switch(geometry_type_id) {
      case 1:
        if (d.radius_in_meters) {
          feature = L.circle(geometry_coordinates, d.radius_in_meters, d);
        } else {
          feature = L.circleMarker(geometry_coordinates, d);
          d.radius_in_pixels && feature.setRadius(d.radius_in_pixels);
        }
        break;
      case 2:
        feature = L.polyline(geometry_coordinates, d);
        break;
      case 3:
        feature = L.polygon(geometry_coordinates, d);
        break;
      case 4:
        // MultiPoint
        break;
      case 5:
        feature = L.multiPolyline(geometry_coordinates, d);
        break;
      case 6:
        feature = L.multiPolygon(geometry_coordinates, d);
        break;
    }

    feature.geotable = {'table_id': table_id, 'tbody_id': table_id + i};
    feature.on('click', function() {
      var a = this.geotable;
      var b = $('#' + a.tbody_id).show();
      $('#' + a.table_id + ' tbody').not(b).hide();
      $('#' + a.table_id).show();
    });
    features.push(feature);
  }
  if (features.length) {
    map.fitBounds(L.featureGroup(features).addTo(map).getBounds()).on('click', function() {
      $('#' + table_id).hide();
    });
  }
}

$.each(d.crosscompute.geotable.definitions, draw_map);

$('.geotable-upload').on('uploaded.ir.upload', function(e, d) {
  var upload_id = d.id;
  var field_id = $(this).parent().data('name');
  var target_id = field_id + '-upload';
  var $target = $('#' + target_id);

  $.post('/c/geotable/import_geotable', {'id': upload_id, 'name': field_id})
    .fail(function(d) {
      $target.find('.geotable-map').html(d.responseJSON[field_id]);
    })
    .success(function(html) {
      $('[name=' + target_id + ']').val(upload_id);
      $target.html(html);
      var x = $target.find('script').text();
      var y = '[[' + /(\[.*\]);/.exec(x)[1];
      var z = $.parseJSON(y.replace(/'/g, '"'));
      draw_map(field_id, z);
    });
});
{% endmacro %}

{% macro render_argument(data_item) %}
{% set key = data_item.key %}
<div data-name="{{ key }}">{{ render_upload_button(id='%s-upload-button' % key, text='Upload', class='btn-lg geotable-upload') }}</div>
<div id="{{ key }}-upload">{{ render_property(data_item) }}</div>
<input name="{{ key }}-upload" type="hidden">
{% endmacro %}

{% macro render_property(data_item, stamp='') %}
{% set key = data_item.key + stamp %}
{% if data_item.value is not none %}
{% set items, properties = data_item.value.interpret() %}
{% set columns = items[-1].columns if items else [] %}
<div id="{{ key }}-map" class="geotable-map"></div>
<table id="{{ key }}-table" class="table geotable-table">
<thead><tr>{% for column_name in column_names %}<th>{{ column_name }}</th>{% endfor %}</tr></thead>
{% for geometry_type_id, geometry_coordinates, local_properties, local_table in items %}
<tbody id="{{ key }}-row{{ loop.index0 }}">
{%- for index, row in local_table.fillna('').iterrows() -%}
<tr>{% for value in row %}<td>{{ value }}</td>{% endfor %}</tr>
{%- endfor -%}
</tbody>
{% endfor %}
</table>
<script>
d.crosscompute.geotable.definitions['{{ key }}'] = [[
{% for geometry_type_id, geometry_coordinates, local_properties, local_table in items %}
[{{ geometry_type_id }}, {{ geometry_coordinates }}, {
{%- for k, v in local_properties.items() %}
'{{ k }}': '{{ v }}'
{%- if not loop.last %},{% endif %}
{% endfor -%}
}]
{%- if not loop.last %},{% endif %}
{% endfor %}], {{ properties }}];
</script>
{% endif %}
{%- endmacro %}

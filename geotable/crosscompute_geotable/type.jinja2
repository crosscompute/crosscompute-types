{% macro head_style_loaded() %}
<link rel="stylesheet" href="//api.mapbox.com/mapbox.js/v2.2.4/mapbox.css">
{% endmacro %}

{% macro head_style_inline() %}
.geotable-map {height: 300px}
.geotable-table {display: none}
{% endmacro %}

{% macro head_script_inline() %}
var map_definitions = {};
{% endmacro %}

{% macro body_script_loaded() %}
<script src='//api.mapbox.com/mapbox.js/v2.2.4/mapbox.js'></script>
{% endmacro %}

{% macro body_script_inline() %}
function get_tile_layer_id(key) {
  try {
    return /(streets|light|dark|satellite|streets-satellite|wheatpaste|streets-basic|comic|outdoors|run-bike-hike|pencil|pirates|emerald|high-contrast)_geotable/.exec(key)[1];
  } catch(e) {
    return 'streets';
  }
}
L.mapbox.accessToken = '{{ get_os_environment_variable('MAPBOX_TOKEN', 'pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpamVuY3cxbzAwMG12ZGx4cGljbGtqMGUifQ.vpDqms08MBqoRgp667Yz5Q') }}';
$.each(map_definitions, function(k, v) {
  var map_id = k + '_', table_id = k + '__';
  var map = L.mapbox.map(map_id, 'mapbox.' + get_tile_layer_id(k)), features = [], feature_packs = v[0], properties = v[1];
  for (var i = 0; i < feature_packs.length; i++) {
    var p = feature_packs[i], geometry_type_id = p[0], geometry_coordinates = p[1], d = $.extend({'color': 'black', 'weight': 3, 'opacity': 0.7, 'fillColor': 'yellow', 'fillOpacity': 0.5}, properties, p[2]), feature;

    switch(geometry_type_id) {
      case 1:
        if (d.radius_in_meters) {
          feature = L.circle(geometry_coordinates, d.radius_in_meters, d);
        } else {
          feature = L.circleMarker(geometry_coordinates, d);
          d.radius_in_pixels && feature.setRadius(d.radius_in_pixels);
        }
        break;
      case 2:
        feature = L.polyline(geometry_coordinates, d);
        break;
      case 3:
        feature = L.polygon(geometry_coordinates, d);
        break;
      case 4:
        // MultiPoint
        break;
      case 5:
        feature = L.multiPolyline(geometry_coordinates, d);
        break;
      case 6:
        feature = L.multiPolygon(geometry_coordinates, d);
        break;
    }

    feature.geotable = {'table_id': table_id, 'tbody_id': table_id + i};
    feature.on('click', function() {
      var a = this.geotable;
      var b = $('#' + a.tbody_id).show();
      $('#' + a.table_id + ' tbody').not(b).hide();
      $('#' + a.table_id).show();
    });
    features.push(feature);
  }
  map.fitBounds(L.featureGroup(features).addTo(map).getBounds()).on('click', function() {
    $('#' + table_id).hide();
  });
});
{% endmacro %}

{% macro render_query(key) %}
{% endmacro %}

{% macro render_value(key, value) %}
{% set items, properties, column_names = value %}
<h3>{{ key }}</h3>
<div id="{{ key }}_" class="geotable-map"></div>
<table id="{{ key }}__" class="table geotable-table">
<thead><tr>{% for column_name in column_names %}<th>{{ column_name }}</th>{% endfor %}</tr></thead>
{% for geometry_type_id, geometry_coordinates, local_properties, local_table in items %}
<tbody id="{{ key }}__{{ loop.index0 }}">
{%- for index, row in local_table.fillna('').iterrows() -%}
<tr>{% for value in row %}<td>{{ value }}</td>{% endfor %}</tr>
{%- endfor -%}
</tbody>
{% endfor %}
</table>
<script>
map_definitions['{{ key }}'] = [[
{% for geometry_type_id, geometry_coordinates, local_properties, local_table in items %}
[{{ geometry_type_id }}, {{ geometry_coordinates }}, {
{%- for k, v in local_properties.items() %}
'{{ k }}': '{{ v }}'
{%- if not loop.last %},{% endif %}
{% endfor -%}
}]
{%- if not loop.last %},{% endif %}
{% endfor %}], {{ properties }}];
</script>
{%- endmacro %}
